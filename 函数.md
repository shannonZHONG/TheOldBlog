# javascript 函数 
函数

## 1.0 声明函数的五种方式：
### 1.0.1具名函数 

```
function   X(输入1，输入2 ）{
 return undefined；
}
console.log(X)
```

逐词,逐行解析：<br>
声明关键字 ： function <br>
类似 var ： var 声明一个变量 <br>
function 声明 一个函数 <br>
对比变量，变量包含了7种数据类型 <br>
但函数只能是函数，或者说 函数 是对象的一种， 一种变量的特例<br>

X 的用处：<br>
当你调用这个函数的时， 就需要这个X <br>

Return undefined   你不写的话， 游览器也会帮你自动添加 <br>

console.log(X)  会把任何数据类型 都变成 字符串  <br>
因为会强制给X 添加一个method: toString <br>

```
console.log = function(a){
    alert(a)
    return  undefined 
}
```
每一次 游览器里面打印 都会有undefined <br>
所以 它打印什么和返回什么  0关系 <br>


### 1.0.2 匿名函数 
声明一个没有名字的函数，然后把这个没有名字的函数赋给一个变量 <br>

```
var test
test = function(x,y){
 return x + y 
}
test(2,3)
```


### 1.0.3 具名函数被赋值  

```
var x = function y(input1,input2){}
```


#### 1.0.3.1 具名函数被赋值与具名函数的差异 
```
var x = function A(){console.log("the diff between functionA and functionB ")}
x();
console.log(A)


```


```
B();
function B(){ console.log("the diff between functionA and functionB ") }
console.log(B)
```

Function B 函数B被定义的方式， 被Javascript Engine  提升到global scope 。意思：在global scope 里， functionB 可以被任意调用 。<br>

function A 被当作变量赋给了变量x，不过function  A 函数A 被定义的方式和B 一样，但是却没有被javascript Engine  提升到global scope 。<br>
意思：在global scope 里，function A 不可以被随意调用且只能被变量A 使用。 <br>

换一种方法：
Js 的不一致性。  <br>
虽然function A 和function B 函数AB 被定义的方式 是一样的，但是仅仅是因为被放置的位置不一样，所造成的结果就不一样。 <br>

用图来说明不一样的地方：<br>
![](javascript%20%E5%87%BD%E6%95%B0/%E5%86%99%E4%BB%A3%E7%A0%81%E5%95%A6%EF%BC%81.jpg)


### 1.0. 4 window.Function
```
var n = 1
var sum = new Function('a', 'b', 'return a+'+ n +' +b');
console.log(sum(2, 6));
// 9

```

参考： [Function constructor creates a new Function object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function)
            

### 1.0.5 箭头函数 

```
sum = (x,y) =>{return x + y}
sum = (x,y) => x+y
sum(1,2)
n2 = n => n*n 
```

花括号 和 return 必须一起省略<br> 
如果参数只有一个 那么参数的括号也可以省略 <br>

## 2.0关于函数的name property 

```
function f(){} 
f.name;// "f'

var f2 = function (){} 
f2.name;// "f2"

var f3 = function f4(){}
f3.name;//"f4"

f5 = new Function('x','y','return x+y')
f5.name;//anonymous
```

## 3.0函数的到底是什么？
### 3.0.1定义：
函数是一个对象。可以执行代码的对象就是函数。<br>
### 3.0.2怎么写一个函数：
 确定好输入什么， 输出什么 <br>
### 3.0.3函数在我们看不见的地方，做了什么？ 
不考虑函数被调用之后，看不见的地方发生了什么<br>
只考虑 函数被调用之前，也就是 像下面代码这样，函数在看不见的地方，是怎么被存储的？<br>

```
function test(){}
```

**当作字符串存**  

### 3.0.4 应该以哪种方式来调用函数？
```
function test(input1,input2){
 var sum;
 sum = input1 + input2;
 return sum
}
test(1,2);// 3 
test.call(undefined,1,2);//3

```

结果都一样。<br>
差别在：<br>
第一种是语法糖。<br>
虽然看上去 少写了一个 undefined，call。<br>
“糖“吃多了 不好 。<br>
第二种好。 <br>
为什么？<br>
因为学习JavaScript 有一个绕不过的知识点： this <br>
This 的出场大多数是和 function 在一起的 <br>
但是this 的值 不是取决于 function<br>
而是 取决于 function 背后的那个 object  <br>
回到call<br>
当你用call method， 第一个参数 就是this或者说是this 指向的object，这样的话，this 的值 就一目了然。<br>
 
## 4.0函数中的一个零件：argument 和另外一个谜： this 
回到 call `test.call(undefined,1,2)`<br>
This：第一个参数 undefined  可以用 this 得到 ；<br>
1,2: 是arguments；<br>

![](javascript%20%E5%87%BD%E6%95%B0/127_0_0_1_51817_example_adder-test_html.jpg)

这就很奇怪了 前面才说了 call 函数 第一个 参数是object 为什么是undefined？ 因为 当this 指向window， 默认就是undefined 。 <br>

但是如果在严格模式下 ， undefined 是undefined .<br>

![](javascript%20%E5%87%BD%E6%95%B0/127_0_0_1_51817_example_adder-test_html.jpg)


![](javascript%20%E5%87%BD%E6%95%B0/127_0_0_1_51817_example_adder-test_html.jpg)

返回的是一个伪数组 。 <br>
arguments的_prototype_ 不等于 Array.prototype 而是等于object.prototype <br>
即使仅仅有 0 1 2 3 和length 这些属性 <br>
![](javascript%20%E5%87%BD%E6%95%B0/127_0_0_1_51817_example_adder-test_html.jpg)

如果 是真数组 那么只有数组才有的push 为什么arguments不能使用？会报错 <br>
![](javascript%20%E5%87%BD%E6%95%B0/127_0_0_1_51817_example_adder-test_html.jpg)


那arguments 到底是什么？<br>
一个伪数组：array-like object <br>
更进一步说：原形链当中没有array.prototype<br>
更更近一步说：<br>
`arguments.__prototype__ === Array.prototype `
返回的是false <br>
更更更近一步说：在原形链当中找就没有和Array.prototype 有关的  <br>
一个仅仅只是有 length 0 1 2 3 属性的对象而已 <br>


## 5.0 call Stack 

不是 first in first out <br>
而是 first in last out  <br>
先进后出  <br>

## 6.0 递归 
未完待续

 
##  你真的明白JavaScript函数的作用？
未完待续  放题  

